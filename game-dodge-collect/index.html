<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Dodge & Collect</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121a33; --text:#e8eeff; --muted:#9db0ff;
      --good:#32e875; --bad:#ff4d6d; --accent:#6aa7ff;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 700px at 50% 20%, #16214a 0%, var(--bg) 60%); color:var(--text); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    .wrap{max-width:980px; margin:0 auto; padding:16px; display:grid; grid-template-rows:auto 1fr auto; gap:12px; height:100%; box-sizing:border-box;}
    header{display:flex; align-items:center; justify-content:space-between; gap:12px;}
    .title{display:flex; flex-direction:column; line-height:1.1}
    .title b{font-size:18px}
    .title span{font-size:12px; color:var(--muted)}
    .hud{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end}
    .chip{background:rgba(18,26,51,0.9); border:1px solid rgba(255,255,255,0.08); border-radius:10px; padding:8px 10px; font-size:13px; display:flex; gap:6px; align-items:baseline}
    .chip small{color:var(--muted)}
    canvas{width:100%; height:100%; background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.07)); border-radius:14px; border:1px solid rgba(255,255,255,0.08); box-shadow:0 20px 60px rgba(0,0,0,0.35); touch-action:none;}
    footer{display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; color:var(--muted); font-size:12px}
    button{appearance:none; border:1px solid rgba(255,255,255,0.14); background:rgba(18,26,51,0.9); color:var(--text);
      padding:8px 10px; border-radius:10px; font-weight:600; cursor:pointer;}
    button:hover{border-color:rgba(106,167,255,0.55)}
    .row{display:flex; gap:8px; flex-wrap:wrap}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <b>Dodge & Collect</b>
        <span>Collect green. Dodge red. Survive the levels.</span>
      </div>
      <div class="hud">
        <div class="chip"><small>Score</small><b id="score">0</b></div>
        <div class="chip"><small>Level</small><b id="level">1</b></div>
        <div class="chip"><small>Lives</small><b id="lives">3</b></div>
        <div class="chip"><small>Best</small><b id="best">0</b></div>
        <div class="row">
          <button id="btnPause" title="P">Pause</button>
          <button id="btnRestart" title="R">Restart</button>
        </div>
      </div>
    </header>

    <canvas id="c" width="960" height="540" aria-label="game canvas"></canvas>

    <footer>
      <div>Controls: <b>WASD</b>/<b>Arrow keys</b> • <b>Space</b> dash • <b>P</b> pause • <b>R</b> restart</div>
      <div>Mobile: drag anywhere to move • double-tap to dash</div>
    </footer>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const elScore = document.getElementById('score');
  const elLevel = document.getElementById('level');
  const elLives = document.getElementById('lives');
  const elBest  = document.getElementById('best');
  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');

  // Resize to fit while keeping internal resolution-ish.
  function fitCanvas() {
    const rect = canvas.getBoundingClientRect();
    // Keep a consistent internal pixel density
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.max(320, Math.floor(rect.width * dpr));
    const h = Math.max(240, Math.floor(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
    }
  }
  new ResizeObserver(fitCanvas).observe(canvas);
  fitCanvas();

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a,b) => a + Math.random()*(b-a);

  const bestKey = 'dodge_collect_best_v1';
  let best = Number(localStorage.getItem(bestKey) || 0);
  elBest.textContent = best;

  const state = {
    running: true,
    gameOver: false,
    score: 0,
    level: 1,
    lives: 3,
    time: 0,
    shake: 0,

    // player
    p: { x: 0, y: 0, r: 16, vx: 0, vy: 0, speed: 420, dash: 0, dashCD: 0 },

    // entities
    goods: [],
    bads: [],
    particles: [],

    // input
    keys: new Set(),
    pointer: { active:false, x:0, y:0, lastTap:0 },
  };

  function reset() {
    state.running = true;
    state.gameOver = false;
    state.score = 0;
    state.level = 1;
    state.lives = 3;
    state.time = 0;
    state.shake = 0;
    state.goods.length = 0;
    state.bads.length = 0;
    state.particles.length = 0;
    state.p.x = canvas.width * 0.5;
    state.p.y = canvas.height * 0.7;
    state.p.vx = 0;
    state.p.vy = 0;
    state.p.dash = 0;
    state.p.dashCD = 0;
    spawnWave();
    syncHUD();
  }

  function syncHUD() {
    elScore.textContent = Math.floor(state.score);
    elLevel.textContent = state.level;
    elLives.textContent = state.lives;
    elBest.textContent  = best;
    btnPause.textContent = state.running ? 'Pause' : 'Resume';
  }

  function spawnWave() {
    // Difficulty scales with level.
    const w = canvas.width, h = canvas.height;
    const goodCount = 3 + Math.floor(state.level * 0.6);
    const badCount  = 2 + Math.floor(state.level * 0.8);

    for (let i=0;i<goodCount;i++) {
      state.goods.push({
        x: rand(40, w-40),
        y: rand(-h*0.8, -40),
        r: rand(10, 14),
        vy: rand(90, 140) + state.level*12,
        vx: rand(-40, 40),
        spin: rand(-2,2),
        t: 0,
      });
    }
    for (let i=0;i<badCount;i++) {
      state.bads.push({
        x: rand(40, w-40),
        y: rand(-h*1.0, -60),
        r: rand(12, 18),
        vy: rand(120, 180) + state.level*18,
        vx: rand(-60, 60),
        wob: rand(1.0, 2.5),
        t: rand(0, Math.PI*2),
      });
    }
  }

  function popParticles(x,y,color,count=16) {
    for (let i=0;i<count;i++) {
      const a = rand(0, Math.PI*2);
      const s = rand(80, 420);
      state.particles.push({
        x, y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s,
        life: rand(0.25, 0.75),
        t: 0,
        color,
        r: rand(1.5, 3.5)
      });
    }
  }

  function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

  function damage() {
    state.lives -= 1;
    state.shake = 0.25;
    popParticles(state.p.x, state.p.y, '#ff4d6d', 28);
    if (state.lives <= 0) {
      state.gameOver = true;
      state.running = false;
      // update best
      if (state.score > best) {
        best = Math.floor(state.score);
        localStorage.setItem(bestKey, String(best));
      }
    }
    syncHUD();
  }

  function addScore(amt) {
    state.score += amt;
    if (state.score > best) {
      best = Math.floor(state.score);
      localStorage.setItem(bestKey, String(best));
    }
    syncHUD();
  }

  // Input
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (['arrowup','arrowdown','arrowleft','arrowright',' ','p','r','w','a','s','d'].includes(k) || ['p','r'].includes(k)) e.preventDefault();

    if (k === 'p') togglePause();
    else if (k === 'r') reset();
    else state.keys.add(k);

    if (k === ' ') tryDash();
  }, { passive:false });

  window.addEventListener('keyup', (e) => {
    state.keys.delete(e.key.toLowerCase());
  });

  function pointerToCanvas(clientX, clientY) {
    const r = canvas.getBoundingClientRect();
    const dpr = canvas.width / r.width;
    return { x:(clientX - r.left)*dpr, y:(clientY - r.top)*dpr };
  }

  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    state.pointer.active = true;
    const p = pointerToCanvas(e.clientX, e.clientY);
    state.pointer.x = p.x; state.pointer.y = p.y;

    const now = performance.now();
    if (now - state.pointer.lastTap < 300) tryDash();
    state.pointer.lastTap = now;
  });
  canvas.addEventListener('pointermove', (e) => {
    if (!state.pointer.active) return;
    const p = pointerToCanvas(e.clientX, e.clientY);
    state.pointer.x = p.x; state.pointer.y = p.y;
  });
  canvas.addEventListener('pointerup', () => { state.pointer.active = false; });
  canvas.addEventListener('pointercancel', () => { state.pointer.active = false; });

  btnPause.addEventListener('click', togglePause);
  btnRestart.addEventListener('click', reset);

  function togglePause() {
    if (state.gameOver) return;
    state.running = !state.running;
    syncHUD();
  }

  function tryDash() {
    if (state.gameOver) return;
    if (state.p.dashCD > 0) return;
    state.p.dash = 0.12;
    state.p.dashCD = 0.65;
  }

  function update(dt) {
    state.time += dt;

    // level progression: clear wave => next level
    if (state.goods.length === 0 && state.bads.length === 0) {
      state.level += 1;
      spawnWave();
      syncHUD();
    }

    // Player movement
    const p = state.p;
    let ix = 0, iy = 0;

    if (state.pointer.active) {
      // steer toward pointer
      const dx = state.pointer.x - p.x;
      const dy = state.pointer.y - p.y;
      const len = Math.hypot(dx,dy) || 1;
      ix = dx/len; iy = dy/len;
      // deadzone
      if (len < 10) { ix = 0; iy = 0; }
    } else {
      const k = state.keys;
      if (k.has('arrowleft') || k.has('a')) ix -= 1;
      if (k.has('arrowright') || k.has('d')) ix += 1;
      if (k.has('arrowup') || k.has('w')) iy -= 1;
      if (k.has('arrowdown') || k.has('s')) iy += 1;
      const len = Math.hypot(ix,iy) || 1;
      ix /= len; iy /= len;
    }

    const dashMul = p.dash > 0 ? 2.4 : 1.0;
    const accel = p.speed * dashMul;
    // simple smoothing
    p.vx = ix * accel;
    p.vy = iy * accel;

    p.x += p.vx * dt;
    p.y += p.vy * dt;

    p.x = clamp(p.x, p.r+6, canvas.width - p.r-6);
    p.y = clamp(p.y, p.r+6, canvas.height - p.r-6);

    if (p.dash > 0) p.dash -= dt;
    if (p.dashCD > 0) p.dashCD -= dt;

    // Update entities
    for (const g of state.goods) {
      g.t += dt;
      g.x += g.vx * dt;
      g.y += g.vy * dt;
      // bounce off walls a bit
      if (g.x < g.r+10 || g.x > canvas.width - g.r-10) g.vx *= -1;
    }
    for (const b of state.bads) {
      b.t += dt;
      const wobX = Math.sin(b.t * b.wob) * 60;
      b.x += (b.vx + wobX) * dt;
      b.y += b.vy * dt;
      if (b.x < b.r+10 || b.x > canvas.width - b.r-10) b.vx *= -1;
    }

    // Cull offscreen
    state.goods = state.goods.filter(g => g.y < canvas.height + 80);
    state.bads  = state.bads.filter(b => b.y < canvas.height + 100);

    // Collisions
    for (let i=state.goods.length-1;i>=0;i--) {
      const g = state.goods[i];
      if (dist2(p.x,p.y,g.x,g.y) <= (p.r+g.r)*(p.r+g.r)) {
        state.goods.splice(i,1);
        addScore(10 + state.level);
        popParticles(g.x,g.y,'#32e875',18);
      }
    }
    for (let i=state.bads.length-1;i>=0;i--) {
      const b = state.bads[i];
      if (dist2(p.x,p.y,b.x,b.y) <= (p.r+b.r)*(p.r+b.r)) {
        state.bads.splice(i,1);
        damage();
      }
    }

    // Passive score for surviving
    addScore(dt * (0.6 + state.level*0.08));

    // Particles
    state.particles = state.particles.filter(pt => {
      pt.t += dt;
      pt.x += pt.vx * dt;
      pt.y += pt.vy * dt;
      pt.vx *= Math.pow(0.02, dt); // strong damping
      pt.vy *= Math.pow(0.02, dt);
      return pt.t < pt.life;
    });

    // screenshake decay
    if (state.shake > 0) state.shake = Math.max(0, state.shake - dt);

    syncHUD();
  }

  function draw() {
    const w = canvas.width, h = canvas.height;

    // camera shake
    const shake = state.shake;
    const sx = shake ? rand(-1,1) * 14 * shake : 0;
    const sy = shake ? rand(-1,1) * 14 * shake : 0;

    ctx.save();
    ctx.translate(sx, sy);

    ctx.clearRect(-20, -20, w+40, h+40);

    // background grid
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    const step = 48;
    for (let x=0; x<w; x+=step) {
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    for (let y=0; y<h; y+=step) {
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Entities
    for (const g of state.goods) {
      const glow = 10;
      ctx.beginPath();
      ctx.fillStyle = 'rgba(50,232,117,0.20)';
      ctx.arc(g.x, g.y, g.r + glow, 0, Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = '#32e875';
      ctx.arc(g.x, g.y, g.r, 0, Math.PI*2);
      ctx.fill();
    }

    for (const b of state.bads) {
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,77,109,0.20)';
      ctx.arc(b.x, b.y, b.r + 10, 0, Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = '#ff4d6d';
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }

    // Player
    const p = state.p;
    const dash = p.dash > 0;
    ctx.beginPath();
    ctx.fillStyle = dash ? '#6aa7ff' : '#e8eeff';
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();

    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.stroke();

    // Dash cooldown ring
    if (p.dashCD > 0) {
      const t = clamp(p.dashCD / 0.65, 0, 1);
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(106,167,255,0.7)';
      ctx.lineWidth = 4;
      ctx.arc(p.x, p.y, p.r + 10, -Math.PI/2, -Math.PI/2 + (1-t)*Math.PI*2);
      ctx.stroke();
    }

    // Particles
    for (const pt of state.particles) {
      const a = 1 - (pt.t / pt.life);
      ctx.globalAlpha = a;
      ctx.fillStyle = pt.color;
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, pt.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Overlay: paused / game over
    if (!state.running) {
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0,0,w,h);

      ctx.textAlign = 'center';
      ctx.fillStyle = '#e8eeff';
      ctx.font = `700 ${Math.floor(Math.min(w,h)*0.06)}px ui-sans-serif, system-ui`;
      ctx.fillText(state.gameOver ? 'GAME OVER' : 'PAUSED', w/2, h*0.43);

      ctx.font = `500 ${Math.floor(Math.min(w,h)*0.028)}px ui-sans-serif, system-ui`;
      const line1 = state.gameOver ? `Score: ${Math.floor(state.score)}   Best: ${best}` : 'Press P to resume';
      const line2 = state.gameOver ? 'Press R to restart' : 'Space / double-tap to dash';
      ctx.fillStyle = 'rgba(232,238,255,0.9)';
      ctx.fillText(line1, w/2, h*0.52);
      ctx.fillText(line2, w/2, h*0.58);
    }

    ctx.restore();
  }

  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (state.running) update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
