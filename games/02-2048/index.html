<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>2048</title>
  <link rel="stylesheet" href="../_shared.css"/>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title"><b>2048</b><span>Swipe/arrow keys. Merge tiles to reach 2048.</span></div>
    <div class="hud">
      <div class="chip"><small>Score</small><b id="score">0</b></div>
      <div class="chip"><small>Best</small><b id="best">0</b></div>
      <button id="btnRestart">Restart</button>
      <a class="chip" href="../.."><small>Back</small><b>Home</b></a>
    </div>
  </header>
  <canvas id="c" width="720" height="720"></canvas>
  <footer>
    <div>Controls: <b>Arrow/WASD</b> • Mobile: <b>swipe</b> • R restart</div>
    <div>Tip: keep the biggest tile in a corner.</div>
  </footer>
</div>
<script>
(() => {
  const c=document.getElementById('c');
  const ctx=c.getContext('2d');
  const elScore=document.getElementById('score');
  const elBest=document.getElementById('best');
  const btnRestart=document.getElementById('btnRestart');

  function fit(){
    const r=c.getBoundingClientRect();
    const dpr=Math.min(2, devicePixelRatio||1);
    const s=Math.floor(Math.min(r.width, window.innerHeight*0.72)*dpr);
    const size=Math.max(320, s);
    if(c.width!==size||c.height!==size){c.width=size;c.height=size;}
  }
  new ResizeObserver(fit).observe(c); fit();

  const keyBest='mini_2048_best_v1';
  let best=Number(localStorage.getItem(keyBest)||0);
  elBest.textContent=best;

  const N=4;
  let grid, score=0, over=false;

  function emptyCells(){
    const cells=[];
    for(let r=0;r<N;r++) for(let col=0;col<N;col++) if(!grid[r][col]) cells.push([r,col]);
    return cells;
  }

  function addTile(){
    const cells=emptyCells();
    if(!cells.length) return;
    const [r,col]=cells[(Math.random()*cells.length)|0];
    grid[r][col]=(Math.random()<0.9)?2:4;
  }

  function reset(){
    grid=Array.from({length:N},()=>Array.from({length:N},()=>0));
    score=0; over=false;
    addTile(); addTile();
    sync();
  }

  function sync(){
    elScore.textContent=score;
    if(score>best){best=score; localStorage.setItem(keyBest,String(best)); elBest.textContent=best;}
  }

  function canMove(){
    if(emptyCells().length) return true;
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      const v=grid[r][c];
      if(r+1<N && grid[r+1][c]===v) return true;
      if(c+1<N && grid[r][c+1]===v) return true;
    }
    return false;
  }

  function slideLine(line){
    // line is array of values
    const vals=line.filter(v=>v);
    let gained=0;
    for(let i=0;i<vals.length-1;i++){
      if(vals[i]===vals[i+1]){vals[i]*=2; gained+=vals[i]; vals.splice(i+1,1);}
    }
    while(vals.length<N) vals.push(0);
    return {vals, gained};
  }

  function move(dir){
    if(over) return;
    let moved=false, gainedTotal=0;

    const get = (r,c)=>grid[r][c];
    const set = (r,c,v)=>{grid[r][c]=v;};

    for(let i=0;i<N;i++){
      let coords=[];
      for(let j=0;j<N;j++){
        if(dir==='left') coords.push([i,j]);
        if(dir==='right') coords.push([i,N-1-j]);
        if(dir==='up') coords.push([j,i]);
        if(dir==='down') coords.push([N-1-j,i]);
      }
      const line=coords.map(([r,c])=>get(r,c));
      const {vals,gained}=slideLine(line);
      gainedTotal+=gained;
      for(let k=0;k<coords.length;k++){
        const [r,c]=coords[k];
        if(get(r,c)!==vals[k]) moved=true;
        set(r,c,vals[k]);
      }
    }

    if(moved){
      score+=gainedTotal;
      addTile();
      sync();
      if(!canMove()) over=true;
    }
  }

  // input
  window.addEventListener('keydown',(e)=>{
    const k=e.key.toLowerCase();
    if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d','r'].includes(k)) e.preventDefault();
    if(k==='r') reset();
    if(k==='arrowleft'||k==='a') move('left');
    if(k==='arrowright'||k==='d') move('right');
    if(k==='arrowup'||k==='w') move('up');
    if(k==='arrowdown'||k==='s') move('down');
  },{passive:false});

  let p0=null;
  c.addEventListener('pointerdown',(e)=>{p0={x:e.clientX,y:e.clientY};});
  c.addEventListener('pointerup',(e)=>{
    if(!p0) return;
    const dx=e.clientX-p0.x, dy=e.clientY-p0.y;
    const ax=Math.abs(dx), ay=Math.abs(dy);
    if(Math.max(ax,ay)<18) {p0=null; return;}
    if(ax>ay) move(dx>0?'right':'left'); else move(dy>0?'down':'up');
    p0=null;
  });

  btnRestart.onclick=reset;

  function colorFor(v){
    if(!v) return 'rgba(255,255,255,0.05)';
    const t=Math.log2(v);
    const hue=(210 - t*10 + 360)%360;
    return `hsl(${hue} 70% ${Math.max(35, 68 - t*2)}%)`;
  }

  function draw(){
    const w=c.width, h=c.height;
    ctx.clearRect(0,0,w,h);
    const pad=Math.floor(w*0.04);
    const gap=Math.floor(w*0.02);
    const tile=(w - pad*2 - gap*(N-1))/N;

    // board
    ctx.fillStyle='rgba(18,26,51,0.9)';
    ctx.beginPath(); ctx.roundRect(pad-10,pad-10,w-(pad-10)*2,h-(pad-10)*2,18); ctx.fill();

    ctx.textAlign='center';
    ctx.textBaseline='middle';

    for(let r=0;r<N;r++) for(let col=0;col<N;col++){
      const v=grid[r][col];
      const x=pad + col*(tile+gap);
      const y=pad + r*(tile+gap);
      ctx.fillStyle=colorFor(v);
      ctx.beginPath(); ctx.roundRect(x,y,tile,tile,14); ctx.fill();
      if(v){
        ctx.fillStyle = v>=8 ? '#071028' : '#071028';
        ctx.font = `800 ${Math.floor(tile*0.28)}px ui-sans-serif, system-ui`;
        ctx.fillStyle = 'rgba(7,16,40,0.92)';
        ctx.fillText(String(v), x+tile/2, y+tile/2);
      }
    }

    if(over){
      ctx.fillStyle='rgba(0,0,0,0.35)';
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle='#e8eeff';
      ctx.font=`800 ${Math.floor(w*0.07)}px ui-sans-serif, system-ui`;
      ctx.fillText('NO MOVES', w/2, h*0.46);
      ctx.font=`600 ${Math.floor(w*0.03)}px ui-sans-serif, system-ui`;
      ctx.fillStyle='rgba(232,238,255,0.9)';
      ctx.fillText('Press R to restart', w/2, h*0.54);
    }

    requestAnimationFrame(draw);
  }

  // polyfill roundRect for older browsers
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect=function(x,y,w,h,r){
      r=Math.min(r,w/2,h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    };
  }

  reset();
  draw();
})();
</script>
</body>
</html>
