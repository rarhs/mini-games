<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Breakout</title>
  <link rel="stylesheet" href="../_shared.css"/>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title"><b>Breakout</b><span>Drag to move paddle. Break all bricks.</span></div>
    <div class="hud">
      <div class="chip"><small>Score</small><b id="score">0</b></div>
      <div class="chip"><small>Lives</small><b id="lives">3</b></div>
      <button id="btnRestart">Restart</button>
      <a class="chip" href="../.."><small>Back</small><b>Home</b></a>
    </div>
  </header>
  <canvas id="c" width="960" height="540"></canvas>
  <footer>
    <div>Mobile: drag anywhere. Desktop: mouse move / A-D keys. Space launches.</div>
    <div>Tip: aim at edges for angles.</div>
  </footer>
</div>
<script>
(() => {
  const c=document.getElementById('c');
  const ctx=c.getContext('2d');
  const elScore=document.getElementById('score');
  const elLives=document.getElementById('lives');
  const btn=document.getElementById('btnRestart');

  function fit(){
    const r=c.getBoundingClientRect();
    const dpr=Math.min(2, devicePixelRatio||1);
    const w=Math.max(360, Math.floor(r.width*dpr));
    const h=Math.max(320, Math.floor((window.innerHeight*0.72)*dpr));
    if(c.width!==w||c.height!==h){c.width=w;c.height=h;}
  }
  new ResizeObserver(fit).observe(c); fit();

  let paddle, ball, bricks, score, lives, started, over;

  function reset(){
    paddle={x:c.width/2, y:c.height*0.90, w:c.width*0.18, h:14};
    ball={x:c.width/2, y:paddle.y-22, r:10, vx:240, vy:-300, stuck:true};
    lives=3; score=0; started=false; over=false;
    bricks=[];
    const rows=5, cols=9;
    const pad=c.width*0.06;
    const gap=c.width*0.012;
    const bw=(c.width-pad*2-gap*(cols-1))/cols;
    const bh=Math.max(16, c.height*0.035);
    for(let r=0;r<rows;r++) for(let col=0;col<cols;col++){
      bricks.push({
        x: pad+col*(bw+gap),
        y: pad+r*(bh+gap),
        w:bw, h:bh,
        hp:1,
        hue:(210+r*18+col*3)%360
      });
    }
    sync();
  }

  function sync(){ elScore.textContent=score; elLives.textContent=lives; }

  function launch(){
    if(over) { reset(); return; }
    if(ball.stuck){ ball.stuck=false; started=true; }
  }

  btn.onclick=reset;
  c.addEventListener('pointerdown', launch);

  let mx=null;
  c.addEventListener('pointermove',(e)=>{
    const r=c.getBoundingClientRect();
    const dpr=c.width/r.width;
    mx=(e.clientX-r.left)*dpr;
  });

  const keys=new Set();
  window.addEventListener('keydown',(e)=>{
    const k=e.key.toLowerCase();
    if(['a','d','arrowleft','arrowright',' ','r'].includes(k)) e.preventDefault();
    if(k===' ') launch();
    if(k==='r') reset();
    keys.add(k);
  },{passive:false});
  window.addEventListener('keyup',(e)=>keys.delete(e.key.toLowerCase()));

  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  function step(dt){
    // paddle
    if(mx!=null) paddle.x = mx;
    let vx=0;
    if(keys.has('a')||keys.has('arrowleft')) vx-=1;
    if(keys.has('d')||keys.has('arrowright')) vx+=1;
    if(vx) paddle.x += vx*520*dt;
    paddle.x = clamp(paddle.x, paddle.w/2+10, c.width-paddle.w/2-10);

    // ball
    if(ball.stuck){
      ball.x=paddle.x;
      ball.y=paddle.y-22;
      return;
    }

    ball.x += ball.vx*dt;
    ball.y += ball.vy*dt;

    // walls
    if(ball.x-ball.r<0){ball.x=ball.r; ball.vx*=-1;}
    if(ball.x+ball.r>c.width){ball.x=c.width-ball.r; ball.vx*=-1;}
    if(ball.y-ball.r<0){ball.y=ball.r; ball.vy*=-1;}

    // paddle collision
    const px=paddle.x-paddle.w/2, py=paddle.y-paddle.h/2;
    if(ball.y+ball.r>py && ball.y-ball.r<py+paddle.h && ball.x>px && ball.x<px+paddle.w && ball.vy>0){
      ball.y=py-ball.r;
      const hit=(ball.x - paddle.x)/(paddle.w/2);
      const speed=Math.hypot(ball.vx, ball.vy);
      const angle = hit * (Math.PI*0.35);
      ball.vx = Math.sin(angle)*speed;
      ball.vy = -Math.cos(angle)*speed;
    }

    // bricks
    for(let i=0;i<bricks.length;i++){
      const b=bricks[i];
      if(!b) continue;
      if(ball.x+ball.r<b.x||ball.x-ball.r>b.x+b.w||ball.y+ball.r<b.y||ball.y-ball.r>b.y+b.h) continue;
      // simple reflect by penetration
      const cx=clamp(ball.x,b.x,b.x+b.w);
      const cy=clamp(ball.y,b.y,b.y+b.h);
      const dx=ball.x-cx, dy=ball.y-cy;
      if(Math.abs(dx)>Math.abs(dy)) ball.vx*=-1; else ball.vy*=-1;
      bricks.splice(i,1); i--;
      score+=5; sync();
      break;
    }

    // lose
    if(ball.y-ball.r>c.height){
      lives--; sync();
      if(lives<=0){ over=true; }
      ball.stuck=true;
      ball.vx=240*(Math.random()<0.5?-1:1);
      ball.vy=-300;
    }

    if(!bricks.length){ over=true; }
  }

  function draw(){
    ctx.clearRect(0,0,c.width,c.height);

    // bricks
    for(const b of bricks){
      ctx.fillStyle=`hsla(${b.hue} 70% 60% / 0.9)`;
      ctx.beginPath(); ctx.roundRect(b.x,b.y,b.w,b.h,10); ctx.fill();
    }

    // paddle
    ctx.fillStyle='#e8eeff';
    ctx.beginPath(); ctx.roundRect(paddle.x-paddle.w/2,paddle.y-paddle.h/2,paddle.w,paddle.h,10); ctx.fill();

    // ball
    ctx.fillStyle='#6aa7ff';
    ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill();

    if(!started){
      ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle='#e8eeff'; ctx.textAlign='center';
      ctx.font=`800 ${Math.floor(Math.min(c.width,c.height)*0.06)}px ui-sans-serif, system-ui`;
      ctx.fillText('TAP / SPACE TO LAUNCH', c.width/2, c.height*0.52);
    }

    if(over){
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle='#e8eeff'; ctx.textAlign='center';
      ctx.font=`900 ${Math.floor(Math.min(c.width,c.height)*0.08)}px ui-sans-serif, system-ui`;
      ctx.fillText(bricks.length? 'GAME OVER':'CLEARED', c.width/2, c.height*0.46);
      ctx.font=`600 ${Math.floor(Math.min(c.width,c.height)*0.03)}px ui-sans-serif, system-ui`;
      ctx.fillStyle='rgba(232,238,255,0.9)';
      ctx.fillText('Press R to restart', c.width/2, c.height*0.55);
    }
  }

  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect=function(x,y,w,h,r){
      r=Math.min(r,w/2,h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    };
  }

  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    if(!over) step(dt);
    draw();
    requestAnimationFrame(loop);
  }

  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
