<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Orbit Dodge (Three.js)</title>
  <link rel="stylesheet" href="../_shared.css"/>
  <style>
    /* Keep it consistent with other games */
    #c{display:block;width:100%;height:100%;}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title"><b>Orbit Dodge</b><span>Three.js. Slide left/right, avoid blocks.</span></div>
    <div class="hud">
      <div class="chip"><small>Score</small><b id="score">0</b></div>
      <div class="chip"><small>Best</small><b id="best">0</b></div>
      <button id="btnRestart">Restart</button>
      <a class="chip" href="../.."><small>Back</small><b>Home</b></a>
    </div>
  </header>

  <canvas id="c"></canvas>

  <footer>
    <div>Controls: drag / A-D / ← → • R restart</div>
    <div>Tip: small moves. Don’t zig-zag too late.</div>
  </footer>
</div>

<script type="module">
  // Local copies of Three.js to avoid CDN blocks.
  import * as THREE from './assets/js/three.module.js';
  import { GLTFLoader } from './assets/js/GLTFLoader.js';

  const canvas = document.getElementById('c');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const btnRestart = document.getElementById('btnRestart');

  const BEST_KEY = 'mini_orbit_dodge_best_v1';
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  bestEl.textContent = String(best);

  function showFatal(msg){
    const div = document.createElement('div');
    div.style.position='absolute';
    div.style.left='0';
    div.style.right='0';
    div.style.top='0';
    div.style.bottom='0';
    div.style.display='grid';
    div.style.placeItems='center';
    div.style.background='rgba(0,0,0,0.45)';
    div.style.color='#e8eeff';
    div.style.fontFamily='ui-sans-serif,system-ui';
    div.style.zIndex='999';
    div.innerHTML = `
      <div style="text-align:center; padding:18px 16px; max-width:560px;">
        <div style="font-weight:900; font-size:28px;">CANVAS / WEBGL ERROR</div>
        <div style="opacity:.9; margin-top:10px; font-weight:600; line-height:1.4;">${msg}</div>
        <div style="opacity:.8; margin-top:12px; font-size:13px;">If you’re on Chrome: Settings → System → enable Hardware Acceleration, then restart Chrome.</div>
      </div>
    `;
    document.body.appendChild(div);
  }

  let renderer;
  try {
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
  } catch (e) {
    console.error(e);
    showFatal('Your browser/device cannot start WebGL. This game needs WebGL to run.');
    throw e;
  }

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0b1020, 10, 55);

  const camera = new THREE.PerspectiveCamera(60, 16 / 9, 0.1, 200);
  camera.position.set(0, 6.5, 12);
  camera.lookAt(0, 0, 0);

  // Lights
  const hemi = new THREE.HemisphereLight(0xe8eeff, 0x0b1020, 0.85);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0x6aa7ff, 0.95);
  dir.position.set(6, 10, 5);
  scene.add(dir);

  // Ground / lane
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 200, 1, 1),
    new THREE.MeshStandardMaterial({ color: 0x121a33, roughness: 1, metalness: 0 })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -1.2;
  ground.position.z = -70;
  scene.add(ground);

  // Side rails (visual)
  const railMat = new THREE.MeshStandardMaterial({ color: 0x2a3970, roughness: 0.9 });
  function rail(x){
    const r = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 200), railMat);
    r.position.set(x, -0.9, -70);
    scene.add(r);
  }
  rail(-5.2); rail(5.2);

  // Loading overlay
  const loading = document.createElement('div');
  loading.id = 'loading';
  loading.style.position = 'absolute';
  loading.style.left = '0';
  loading.style.right = '0';
  loading.style.top = '0';
  loading.style.bottom = '0';
  loading.style.display = 'grid';
  loading.style.placeItems = 'center';
  loading.style.background = 'rgba(0,0,0,0.25)';
  loading.style.backdropFilter = 'blur(2px)';
  loading.style.color = '#e8eeff';
  loading.style.fontFamily = 'ui-sans-serif,system-ui';
  loading.style.zIndex = '10';
  loading.innerHTML = `
    <div style="text-align:center; padding:18px 16px; max-width:520px;">
      <div style="font-weight:900; font-size:34px; letter-spacing:.5px;">LOADING ASSETS</div>
      <div style="opacity:.9; margin-top:10px; font-weight:600;">Low‑poly models (Kenney CC0)</div>
    </div>
  `;
  document.body.appendChild(loading);

  // Assets
  const loader = new GLTFLoader();
  const assets = { character: null, car: null, truck: null };

  function loadGLB(url) {
    return new Promise((resolve, reject) => {
      loader.load(url, (gltf) => resolve(gltf.scene), undefined, reject);
    });
  }

  // Player container (we'll attach the character model here)
  const player = new THREE.Group();
  player.position.set(0, -0.1, 0);
  scene.add(player);

  // Decorative orbit ring
  const ring = new THREE.Mesh(
    new THREE.TorusGeometry(1.2, 0.04, 14, 96),
    new THREE.MeshStandardMaterial({ color: 0x6aa7ff, roughness: 0.4, metalness: 0.3, emissive: 0x112244 })
  );
  ring.rotation.x = Math.PI / 2;
  player.add(ring);

  // Obstacles
  const obstacles = [];
  const fallbackObsGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
  const fallbackObsMat = new THREE.MeshStandardMaterial({ color: 0x32e875, roughness: 0.55, metalness: 0.05, emissive: 0x062013 });

  function cloneModel(src) {
    // Simple clone is enough for these static glb scenes
    return src ? src.clone(true) : null;
  }

  function spawnObstacle(){
    const lane = (Math.random() * 3) | 0; // 0,1,2
    const x = (lane - 1) * 2.4; // -2.4, 0, +2.4

    let m;
    const useTruck = Math.random() < 0.35;
    const model = useTruck ? assets.truck : assets.car;
    if(model){
      m = cloneModel(model);
    } else {
      m = new THREE.Mesh(fallbackObsGeo, fallbackObsMat);
    }

    m.position.set(x, -0.6, -40);
    // Cars point +Z; we want them facing camera. Rotate 180 so they "come at" you.
    m.rotation.y = Math.PI;

    // scale to lane
    m.scale.setScalar(useTruck ? 1.2 : 1.0);

    scene.add(m);
    obstacles.push({ mesh: m, passed: false });
  }

  // Input
  let targetX = 0;
  let dragging = false;
  let lastClientX = 0;

  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if(['arrowleft','arrowright','a','d','r'].includes(k)) e.preventDefault();
    keys.add(k);
    if(k === 'r') reset();
  }, { passive: false });
  window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

  canvas.addEventListener('pointerdown', (e) => {
    dragging = true;
    lastClientX = e.clientX;
    canvas.setPointerCapture?.(e.pointerId);
  });
  canvas.addEventListener('pointerup', () => { dragging = false; });
  canvas.addEventListener('pointercancel', () => { dragging = false; });
  canvas.addEventListener('pointermove', (e) => {
    if(!dragging) return;
    const dx = e.clientX - lastClientX;
    lastClientX = e.clientX;
    targetX += dx * 0.015;
    targetX = Math.max(-3.6, Math.min(3.6, targetX));
  });

  btnRestart.onclick = () => reset();

  function fit(){
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(360, Math.floor(rect.width || (window.innerWidth - 24)));
    const h = Math.max(320, Math.floor(window.innerHeight * 0.72));
    // updateStyle=true so the canvas is visible even if CSS height collapses.
    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  new ResizeObserver(fit).observe(canvas);
  fit();

  let score = 0;
  let speed = 14; // units/sec
  let spawnT = 0;
  let over = false;

  function reset(){
    // clear obstacles
    for(const o of obstacles){
      scene.remove(o.mesh);
    }
    obstacles.length = 0;

    score = 0;
    speed = 14;
    spawnT = 0;
    over = false;
    targetX = 0;
    player.position.set(0, -0.1, 0);
    scoreEl.textContent = '0';

    // prewarm
    for(let i=0;i<3;i++){ spawnObstacle(); obstacles[i].mesh.position.z = -14 - i*10; }
  }

  function setBest(){
    if(score > best){ best = score; localStorage.setItem(BEST_KEY, String(best)); bestEl.textContent = String(best); }
  }

  function aabb(mesh){
    const b = new THREE.Box3().setFromObject(mesh);
    return b;
  }

  const playerBox = new THREE.Box3();

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    // subtle camera sway
    camera.position.x = THREE.MathUtils.lerp(camera.position.x, player.position.x * 0.25, 0.05);
    camera.lookAt(player.position.x * 0.15, -0.3, -6);

    // key controls to adjust target
    if(keys.has('arrowleft') || keys.has('a')) targetX -= 4.0 * dt;
    if(keys.has('arrowright') || keys.has('d')) targetX += 4.0 * dt;
    targetX = Math.max(-3.6, Math.min(3.6, targetX));

    // move player
    player.position.x = THREE.MathUtils.lerp(player.position.x, targetX, 0.18);
    ring.rotation.z += dt * 2.2;

    if(!over){
      // difficulty
      speed = Math.min(28, speed + dt * 0.65);

      // spawn
      spawnT -= dt;
      if(spawnT <= 0){
        spawnObstacle();
        // shorter gaps as speed increases
        const gap = THREE.MathUtils.clamp(1.05 - (speed-14)*0.03, 0.45, 1.05);
        spawnT = gap;
      }

      // move obstacles forward (towards player)
      for(const o of obstacles){
        o.mesh.position.z += speed * dt;
        o.mesh.rotation.x += dt * 0.9;
        o.mesh.rotation.y += dt * 0.7;

        if(!o.passed && o.mesh.position.z > player.position.z + 0.2){
          o.passed = true;
          score += 1;
          scoreEl.textContent = String(score);
          setBest();
        }
      }

      // cleanup old
      while(obstacles.length && obstacles[0].mesh.position.z > 12){
        const old = obstacles.shift();
        scene.remove(old.mesh);
      }

      // collision
      playerBox.setFromObject(player);
      for(const o of obstacles){
        const b = aabb(o.mesh);
        if(playerBox.intersectsBox(b)){
          over = true;
          break;
        }
      }
    }

    // overlay
    if(over){
      // darken with a 2D overlay
      const w = renderer.domElement.width;
      const h = renderer.domElement.height;
      // draw 2D overlay on top of WebGL by using renderer + an extra canvas isn't easy.
      // Instead: animate and show a simple DOM message via title/footer.
      document.title = 'Orbit Dodge — Game Over';
    } else {
      document.title = 'Orbit Dodge (Three.js)';
    }

    renderer.render(scene, camera);

    // DOM overlay (simple)
    if(over){
      // show once
      if(!document.getElementById('over')){
        const div = document.createElement('div');
        div.id = 'over';
        div.style.position = 'absolute';
        div.style.left = '0';
        div.style.right = '0';
        div.style.top = '0';
        div.style.bottom = '0';
        div.style.display = 'grid';
        div.style.placeItems = 'center';
        div.style.background = 'rgba(0,0,0,0.35)';
        div.style.backdropFilter = 'blur(2px)';
        div.style.color = '#e8eeff';
        div.style.fontFamily = 'ui-sans-serif,system-ui';
        div.style.zIndex = '10';
        div.innerHTML = `
          <div style="text-align:center; padding:18px 16px; max-width:520px;">
            <div style="font-weight:900; font-size:44px; letter-spacing:1px;">GAME OVER</div>
            <div style="opacity:.9; margin-top:10px; font-weight:700;">Score: ${score} • Best: ${best}</div>
            <div style="opacity:.8; margin-top:14px; font-weight:600;">Tap Restart or press R</div>
          </div>
        `;
        document.body.appendChild(div);
      }
    } else {
      const div = document.getElementById('over');
      if(div) div.remove();
    }

    requestAnimationFrame(loop);
  }

  async function initAssets(){
    try{
      // local relative URLs (served from this folder)
      const [ch, car, truck] = await Promise.all([
        loadGLB('./assets/models/character.glb'),
        loadGLB('./assets/models/car.glb'),
        loadGLB('./assets/models/truck.glb'),
      ]);

      // Character
      assets.character = ch;
      // Normalize character scale/position
      ch.scale.setScalar(1.2);
      ch.position.set(0, -1.05, 0);
      player.add(ch);

      // Car/truck
      assets.car = car;
      assets.truck = truck;

      // Some Kenney glbs come with their own transforms/materials; keep as-is.
    } catch(e){
      console.error('Asset load failed:', e);
      // Fall back to primitives
      const fallbackPlayer = new THREE.Mesh(
        new THREE.SphereGeometry(0.6, 24, 24),
        new THREE.MeshStandardMaterial({ color: 0xe8eeff, roughness: 0.35, metalness: 0.1 })
      );
      fallbackPlayer.position.set(0, 0.0, 0);
      player.add(fallbackPlayer);
    } finally {
      const el = document.getElementById('loading');
      if(el) el.remove();
    }
  }

  await initAssets();
  reset();
  requestAnimationFrame(loop);
</script>
</body>
</html>
