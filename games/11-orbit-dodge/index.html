<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Orbit Dodge (Three.js)</title>
  <link rel="stylesheet" href="../_shared.css"/>
  <style>
    /* Keep it consistent with other games */
    #c{display:block;width:100%;height:100%;}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title"><b>Orbit Dodge</b><span>Three.js. Slide left/right, avoid blocks.</span></div>
    <div class="hud">
      <div class="chip"><small>Score</small><b id="score">0</b></div>
      <div class="chip"><small>Best</small><b id="best">0</b></div>
      <button id="btnRestart">Restart</button>
      <a class="chip" href="../.."><small>Back</small><b>Home</b></a>
    </div>
  </header>

  <canvas id="c"></canvas>

  <footer>
    <div>Controls: drag / A-D / ← → • R restart</div>
    <div>Tip: small moves. Don’t zig-zag too late.</div>
  </footer>
</div>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

  const canvas = document.getElementById('c');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const btnRestart = document.getElementById('btnRestart');

  const BEST_KEY = 'mini_orbit_dodge_best_v1';
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  bestEl.textContent = String(best);

  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0b1020, 10, 55);

  const camera = new THREE.PerspectiveCamera(60, 16 / 9, 0.1, 200);
  camera.position.set(0, 6.5, 12);
  camera.lookAt(0, 0, 0);

  // Lights
  const hemi = new THREE.HemisphereLight(0xe8eeff, 0x0b1020, 0.85);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0x6aa7ff, 0.95);
  dir.position.set(6, 10, 5);
  scene.add(dir);

  // Ground / lane
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 200, 1, 1),
    new THREE.MeshStandardMaterial({ color: 0x121a33, roughness: 1, metalness: 0 })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -1.2;
  ground.position.z = -70;
  scene.add(ground);

  // Side rails (visual)
  const railMat = new THREE.MeshStandardMaterial({ color: 0x2a3970, roughness: 0.9 });
  function rail(x){
    const r = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 200), railMat);
    r.position.set(x, -0.9, -70);
    scene.add(r);
  }
  rail(-5.2); rail(5.2);

  // Player
  const player = new THREE.Mesh(
    new THREE.SphereGeometry(0.6, 24, 24),
    new THREE.MeshStandardMaterial({ color: 0xe8eeff, roughness: 0.35, metalness: 0.1 })
  );
  player.position.set(0, -0.1, 0);
  scene.add(player);

  // Decorative orbit ring
  const ring = new THREE.Mesh(
    new THREE.TorusGeometry(1.2, 0.04, 14, 96),
    new THREE.MeshStandardMaterial({ color: 0x6aa7ff, roughness: 0.4, metalness: 0.3, emissive: 0x112244 })
  );
  ring.rotation.x = Math.PI / 2;
  player.add(ring);

  // Obstacles
  const obstacles = [];
  const obsGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
  const obsMat = new THREE.MeshStandardMaterial({ color: 0x32e875, roughness: 0.55, metalness: 0.05, emissive: 0x062013 });

  function spawnObstacle(){
    const m = new THREE.Mesh(obsGeo, obsMat);
    const lane = (Math.random() * 3) | 0; // 0,1,2
    const x = (lane - 1) * 2.4; // -2.4, 0, +2.4
    m.position.set(x, -0.1, -40);
    m.rotation.set(Math.random()*0.6, Math.random()*0.6, Math.random()*0.6);
    scene.add(m);
    obstacles.push({ mesh: m, passed: false });
  }

  // Input
  let targetX = 0;
  let dragging = false;
  let lastClientX = 0;

  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if(['arrowleft','arrowright','a','d','r'].includes(k)) e.preventDefault();
    keys.add(k);
    if(k === 'r') reset();
  }, { passive: false });
  window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

  canvas.addEventListener('pointerdown', (e) => {
    dragging = true;
    lastClientX = e.clientX;
    canvas.setPointerCapture?.(e.pointerId);
  });
  canvas.addEventListener('pointerup', () => { dragging = false; });
  canvas.addEventListener('pointercancel', () => { dragging = false; });
  canvas.addEventListener('pointermove', (e) => {
    if(!dragging) return;
    const dx = e.clientX - lastClientX;
    lastClientX = e.clientX;
    targetX += dx * 0.015;
    targetX = Math.max(-3.6, Math.min(3.6, targetX));
  });

  btnRestart.onclick = () => reset();

  function fit(){
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(360, Math.floor(rect.width));
    const h = Math.max(320, Math.floor(window.innerHeight * 0.72));
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  new ResizeObserver(fit).observe(canvas);
  fit();

  let score = 0;
  let speed = 14; // units/sec
  let spawnT = 0;
  let over = false;

  function reset(){
    // clear obstacles
    for(const o of obstacles){ scene.remove(o.mesh); o.mesh.geometry.dispose?.(); }
    obstacles.length = 0;

    score = 0;
    speed = 14;
    spawnT = 0;
    over = false;
    targetX = 0;
    player.position.set(0, -0.1, 0);
    scoreEl.textContent = '0';

    // prewarm
    for(let i=0;i<3;i++){ spawnObstacle(); obstacles[i].mesh.position.z = -14 - i*10; }
  }

  function setBest(){
    if(score > best){ best = score; localStorage.setItem(BEST_KEY, String(best)); bestEl.textContent = String(best); }
  }

  function aabb(mesh){
    const b = new THREE.Box3().setFromObject(mesh);
    return b;
  }

  const playerBox = new THREE.Box3();

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    // subtle camera sway
    camera.position.x = THREE.MathUtils.lerp(camera.position.x, player.position.x * 0.25, 0.05);
    camera.lookAt(player.position.x * 0.15, -0.3, -6);

    // key controls to adjust target
    if(keys.has('arrowleft') || keys.has('a')) targetX -= 4.0 * dt;
    if(keys.has('arrowright') || keys.has('d')) targetX += 4.0 * dt;
    targetX = Math.max(-3.6, Math.min(3.6, targetX));

    // move player
    player.position.x = THREE.MathUtils.lerp(player.position.x, targetX, 0.18);
    ring.rotation.z += dt * 2.2;

    if(!over){
      // difficulty
      speed = Math.min(28, speed + dt * 0.65);

      // spawn
      spawnT -= dt;
      if(spawnT <= 0){
        spawnObstacle();
        // shorter gaps as speed increases
        const gap = THREE.MathUtils.clamp(1.05 - (speed-14)*0.03, 0.45, 1.05);
        spawnT = gap;
      }

      // move obstacles forward (towards player)
      for(const o of obstacles){
        o.mesh.position.z += speed * dt;
        o.mesh.rotation.x += dt * 0.9;
        o.mesh.rotation.y += dt * 0.7;

        if(!o.passed && o.mesh.position.z > player.position.z + 0.2){
          o.passed = true;
          score += 1;
          scoreEl.textContent = String(score);
          setBest();
        }
      }

      // cleanup old
      while(obstacles.length && obstacles[0].mesh.position.z > 12){
        const old = obstacles.shift();
        scene.remove(old.mesh);
      }

      // collision
      playerBox.setFromObject(player);
      for(const o of obstacles){
        const b = aabb(o.mesh);
        if(playerBox.intersectsBox(b)){
          over = true;
          break;
        }
      }
    }

    // overlay
    if(over){
      // darken with a 2D overlay
      const w = renderer.domElement.width;
      const h = renderer.domElement.height;
      // draw 2D overlay on top of WebGL by using renderer + an extra canvas isn't easy.
      // Instead: animate and show a simple DOM message via title/footer.
      document.title = 'Orbit Dodge — Game Over';
    } else {
      document.title = 'Orbit Dodge (Three.js)';
    }

    renderer.render(scene, camera);

    // DOM overlay (simple)
    if(over){
      // show once
      if(!document.getElementById('over')){
        const div = document.createElement('div');
        div.id = 'over';
        div.style.position = 'absolute';
        div.style.left = '0';
        div.style.right = '0';
        div.style.top = '0';
        div.style.bottom = '0';
        div.style.display = 'grid';
        div.style.placeItems = 'center';
        div.style.background = 'rgba(0,0,0,0.35)';
        div.style.backdropFilter = 'blur(2px)';
        div.style.color = '#e8eeff';
        div.style.fontFamily = 'ui-sans-serif,system-ui';
        div.style.zIndex = '10';
        div.innerHTML = `
          <div style="text-align:center; padding:18px 16px; max-width:520px;">
            <div style="font-weight:900; font-size:44px; letter-spacing:1px;">GAME OVER</div>
            <div style="opacity:.9; margin-top:10px; font-weight:700;">Score: ${score} • Best: ${best}</div>
            <div style="opacity:.8; margin-top:14px; font-weight:600;">Tap Restart or press R</div>
          </div>
        `;
        document.body.appendChild(div);
      }
    } else {
      const div = document.getElementById('over');
      if(div) div.remove();
    }

    requestAnimationFrame(loop);
  }

  reset();
  requestAnimationFrame(loop);
</script>
</body>
</html>
